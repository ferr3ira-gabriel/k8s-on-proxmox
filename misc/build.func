#!/usr/bin/env bash

# K3s on Proxmox LXC - Helper Functions
# Based on Proxmox VE Helper-Scripts patterns
# https://github.com/community-scripts/ProxmoxVE

# Colors
RD=$(echo "\033[01;31m")
YW=$(echo "\033[33m")
GN=$(echo "\033[1;92m")
BL=$(echo "\033[36m")
CL=$(echo "\033[m")
BFR="\\r\\033[K"
HOLD="-"
CM="${GN}✓${CL}"
CROSS="${RD}✗${CL}"
TAB="  "
TAB3="      "

# Script settings
set -euo pipefail
shopt -s inherit_errexit nullglob

# Spinner characters
SPINNER="/-\|"

header_info() {
  clear
  cat <<"EOF"
    ██╗  ██╗ █████╗ ███████╗     ██████╗ ███╗   ██╗    ██████╗ ██████╗  ██████╗ ██╗  ██╗███╗   ███╗ ██████╗ ██╗  ██╗
    ██║ ██╔╝██╔══██╗██╔════╝    ██╔═══██╗████╗  ██║    ██╔══██╗██╔══██╗██╔═══██╗╚██╗██╔╝████╗ ████║██╔═══██╗╚██╗██╔╝
    █████╔╝ ╚█████╔╝███████╗    ██║   ██║██╔██╗ ██║    ██████╔╝██████╔╝██║   ██║ ╚███╔╝ ██╔████╔██║██║   ██║ ╚███╔╝ 
    ██╔═██╗ ██╔══██╗╚════██║    ██║   ██║██║╚██╗██║    ██╔═══╝ ██╔══██╗██║   ██║ ██╔██╗ ██║╚██╔╝██║██║   ██║ ██╔██╗ 
    ██║  ██╗╚█████╔╝███████║    ╚██████╔╝██║ ╚████║    ██║     ██║  ██║╚██████╔╝██╔╝ ██╗██║ ╚═╝ ██║╚██████╔╝██╔╝ ██╗
    ╚═╝  ╚═╝ ╚════╝ ╚══════╝     ╚═════╝ ╚═╝  ╚═══╝    ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═╝

    K3s Kubernetes on Proxmox LXC | Based on tutorial by Garrett Mills
EOF
}

msg_info() {
  local msg="$1"
  echo -ne " ${HOLD} ${YW}${msg}...${CL}"
}

msg_ok() {
  local msg="$1"
  echo -e "${BFR} ${CM} ${GN}${msg}${CL}"
}

msg_error() {
  local msg="$1"
  echo -e "${BFR} ${CROSS} ${RD}${msg}${CL}"
}

msg_warn() {
  local msg="$1"
  echo -e "${BFR} ${YW}⚠${CL} ${YW}${msg}${CL}"
}

spinner() {
  local pid=$1
  local delay=0.1
  local spin_i=0
  while ps -p "$pid" &>/dev/null; do
    printf "\r [%c] " "${SPINNER:spin_i++%4:1}"
    sleep $delay
  done
  printf "\r"
}

check_root() {
  if [[ $EUID -ne 0 ]]; then
    msg_error "This script must be run as root"
    exit 1
  fi
}

check_proxmox() {
  if ! command -v pveversion &>/dev/null; then
    msg_error "This script must be run on a Proxmox VE host"
    exit 1
  fi
}

get_next_ct_id() {
  local start_id=${1:-100}
  while pct status "$start_id" &>/dev/null; do
    ((start_id++))
  done
  echo "$start_id"
}

get_available_storage() {
  pvesm status -content rootdir 2>/dev/null | awk 'NR>1 {print $1}' | head -1
}

get_available_templates() {
  pveam available --section system 2>/dev/null | grep -E "(debian|ubuntu|rocky)" | awk '{print $2}'
}

download_template() {
  local storage="$1"
  local template="$2"
  
  # Check if template already exists (use || true to prevent exit on no match)
  if pveam list "$storage" 2>/dev/null | grep -q "$template" 2>/dev/null; then
    msg_ok "Template ${template} already available"
    return 0
  fi
  
  msg_info "Downloading template ${template}"
  echo ""  # New line for download progress
  if pveam download "$storage" "$template"; then
    msg_ok "Downloaded template ${template}"
  else
    msg_error "Failed to download template ${template}"
    return 1
  fi
}

validate_ip() {
  local ip="$1"
  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
    return 0
  else
    return 1
  fi
}

configure_lxc_for_k3s() {
  local ctid="$1"
  local conf_file="/etc/pve/lxc/${ctid}.conf"
  
  if [[ ! -f "$conf_file" ]]; then
    msg_error "Container config not found: ${conf_file}"
    return 1
  fi
  
  msg_info "Configuring LXC ${ctid} for K3s"
  
  # Add required LXC options for K3s/Docker
  if ! grep -q "lxc.apparmor.profile" "$conf_file"; then
    cat >> "$conf_file" <<EOF

# K3s/Docker required settings
lxc.apparmor.profile: unconfined
lxc.cgroup.devices.allow: a
lxc.cap.drop:
lxc.mount.auto: proc:rw sys:rw
EOF
  fi
  
  msg_ok "Configured LXC ${ctid} for K3s"
}

push_kernel_config() {
  local ctid="$1"
  local kernel_config="/boot/config-$(uname -r)"
  
  if [[ -f "$kernel_config" ]]; then
    msg_info "Pushing kernel config to container ${ctid}"
    pct push "$ctid" "$kernel_config" "$kernel_config"
    msg_ok "Pushed kernel config to container ${ctid}"
  else
    msg_warn "Kernel config not found: ${kernel_config}"
  fi
}

setup_kmsg_in_container() {
  local ctid="$1"
  
  msg_info "Setting up /dev/kmsg in container ${ctid}"
  
  # Wait for systemd to be ready
  local retries=30
  while ! pct exec "$ctid" -- systemctl is-system-running &>/dev/null; do
    retries=$((retries - 1))
    if [[ $retries -le 0 ]]; then
      msg_warn "Systemd not fully ready, continuing anyway..."
      break
    fi
    sleep 1
  done
  
  # Create the kmsg script
  pct exec "$ctid" -- bash -c 'cat > /usr/local/bin/conf-kmsg.sh << "KMSGEOF"
#!/bin/sh -e
if [ ! -e /dev/kmsg ]; then
    ln -s /dev/console /dev/kmsg
fi
mount --make-rshared /
KMSGEOF'
  
  pct exec "$ctid" -- chmod +x /usr/local/bin/conf-kmsg.sh
  
  # Create systemd service
  pct exec "$ctid" -- bash -c 'cat > /etc/systemd/system/conf-kmsg.service << "SVCEOF"
[Unit]
Description=Make sure /dev/kmsg exists

[Service]
Type=simple
RemainAfterExit=yes
ExecStart=/usr/local/bin/conf-kmsg.sh
TimeoutStartSec=0

[Install]
WantedBy=default.target
SVCEOF'
  
  # Enable and start the service
  pct exec "$ctid" -- systemctl daemon-reload 2>/dev/null || sleep 2
  pct exec "$ctid" -- systemctl enable --now conf-kmsg 2>/dev/null || true
  
  # Run the script manually as fallback
  pct exec "$ctid" -- /usr/local/bin/conf-kmsg.sh 2>/dev/null || true
  
  msg_ok "Set up /dev/kmsg in container ${ctid}"
}

wait_for_container() {
  local ctid="$1"
  local timeout="${2:-60}"
  local count=0
  
  while ! pct exec "$ctid" -- echo "ready" &>/dev/null; do
    if [[ $count -ge $timeout ]]; then
      msg_error "Timeout waiting for container ${ctid}"
      return 1
    fi
    sleep 1
    ((count++))
  done
}

create_lxc_container() {
  local ctid="$1"
  local hostname="$2"
  local template="$3"
  local storage="$4"
  local template_storage="$5"
  local cores="$6"
  local memory="$7"
  local disk="$8"
  local ip="$9"
  local gateway="${10}"
  local password="${11}"
  local bridge="${12:-vmbr0}"
  
  msg_info "Creating LXC container ${ctid} (${hostname})"
  
  pct create "$ctid" "${template_storage}:vztmpl/${template}" \
    --hostname "$hostname" \
    --cores "$cores" \
    --memory "$memory" \
    --rootfs "${storage}:${disk}" \
    --net0 "name=eth0,bridge=${bridge},ip=${ip},gw=${gateway}" \
    --password "$password" \
    --unprivileged 0 \
    --features nesting=1,keyctl=1 \
    --onboot 1 \
    --start 0
  
  msg_ok "Created LXC container ${ctid} (${hostname})"
}

start_container() {
  local ctid="$1"
  
  msg_info "Starting container ${ctid}"
  pct start "$ctid"
  wait_for_container "$ctid"
  msg_ok "Started container ${ctid}"
}

ensure_curl_installed() {
  local ctid="$1"
  
  if ! pct exec "$ctid" -- which curl &>/dev/null; then
    echo -e " - Installing curl on container ${ctid}..."
    pct exec "$ctid" -- bash -c "apt-get update && apt-get install -y curl"
    msg_ok "Installed curl on container ${ctid}"
  fi
}

install_k3s_control() {
  local ctid="$1"
  local node_name="$2"
  
  ensure_curl_installed "$ctid"
  
  msg_info "Installing K3s control plane on ${node_name}"
  
  pct exec "$ctid" -- bash -c "curl -sfL https://get.k3s.io | sh -s - --disable traefik --node-name ${node_name}"
  
  msg_ok "Installed K3s control plane on ${node_name}"
}

get_k3s_token() {
  local ctid="$1"
  pct exec "$ctid" -- cat /var/lib/rancher/k3s/server/node-token
}

get_k3s_kubeconfig() {
  local ctid="$1"
  pct exec "$ctid" -- cat /etc/rancher/k3s/k3s.yaml
}

install_k3s_worker() {
  local ctid="$1"
  local node_name="$2"
  local control_ip="$3"
  local token="$4"
  
  ensure_curl_installed "$ctid"
  
  msg_info "Joining worker ${node_name} to cluster"
  
  pct exec "$ctid" -- bash -c "curl -sfL https://get.k3s.io | K3S_URL=https://${control_ip}:6443 K3S_TOKEN=${token} sh -s - --node-name ${node_name}"
  
  msg_ok "Joined worker ${node_name} to cluster"
}

install_helm() {
  local ctid="$1"
  
  ensure_curl_installed "$ctid"
  
  msg_info "Installing Helm"
  
  pct exec "$ctid" -- bash -c "curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash"
  
  msg_ok "Installed Helm"
}

install_nginx_ingress() {
  local ctid="$1"
  
  msg_info "Installing NGINX Ingress Controller"
  
  pct exec "$ctid" -- bash -c "
    export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
    helm repo update
    helm install nginx-ingress ingress-nginx/ingress-nginx --set controller.publishService.enabled=true
  "
  
  msg_ok "Installed NGINX Ingress Controller"
}

install_ohmyzsh() {
  local ctid="$1"
  local hostname="$2"
  
  msg_info "Installing base packages on ${hostname}"
  pct exec "$ctid" -- bash -c "apt-get update && apt-get install -y curl git telnet zsh" &>/dev/null
  msg_ok "Installed base packages on ${hostname}"
  
  msg_info "Installing Oh My Zsh on ${hostname}"
  # Install Oh My Zsh non-interactively
  pct exec "$ctid" -- bash -c '
    export RUNZSH=no
    export CHSH=no
    sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
  '
  
  # Set fino theme
  pct exec "$ctid" -- bash -c 'sed -i "s/ZSH_THEME=\"robbyrussell\"/ZSH_THEME=\"fino\"/" ~/.zshrc'
  
  # Set zsh as default shell
  pct exec "$ctid" -- chsh -s /bin/zsh root
  
  msg_ok "Installed Oh My Zsh with fino theme on ${hostname}"
}

cleanup_on_error() {
  local ctids=("$@")
  msg_warn "Cleaning up containers due to error..."
  for ctid in "${ctids[@]}"; do
    if pct status "$ctid" &>/dev/null; then
      pct stop "$ctid" 2>/dev/null || true
      pct destroy "$ctid" 2>/dev/null || true
    fi
  done
}
