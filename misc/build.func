#!/usr/bin/env bash

# K3s on Proxmox LXC - Helper Functions
# Based on Proxmox VE Helper-Scripts patterns
# https://github.com/community-scripts/ProxmoxVE

# Colors
RD=$(echo "\033[01;31m")
YW=$(echo "\033[33m")
GN=$(echo "\033[1;92m")
BL=$(echo "\033[36m")
CL=$(echo "\033[m")
BFR="\\r\\033[K"
HOLD="-"
CM="${GN}✓${CL}"
CROSS="${RD}✗${CL}"
TAB="  "
TAB3="      "

# Script settings
set -euo pipefail
shopt -s inherit_errexit nullglob

# Spinner characters
SPINNER="/-\|"

header_info() {
  clear
  cat <<"EOF"
    ██╗  ██╗ █████╗ ███████╗     ██████╗ ███╗   ██╗    ██████╗ ██████╗  ██████╗ ██╗  ██╗███╗   ███╗ ██████╗ ██╗  ██╗
    ██║ ██╔╝██╔══██╗██╔════╝    ██╔═══██╗████╗  ██║    ██╔══██╗██╔══██╗██╔═══██╗╚██╗██╔╝████╗ ████║██╔═══██╗╚██╗██╔╝
    █████╔╝ ╚█████╔╝███████╗    ██║   ██║██╔██╗ ██║    ██████╔╝██████╔╝██║   ██║ ╚███╔╝ ██╔████╔██║██║   ██║ ╚███╔╝ 
    ██╔═██╗ ██╔══██╗╚════██║    ██║   ██║██║╚██╗██║    ██╔═══╝ ██╔══██╗██║   ██║ ██╔██╗ ██║╚██╔╝██║██║   ██║ ██╔██╗ 
    ██║  ██╗╚█████╔╝███████║    ╚██████╔╝██║ ╚████║    ██║     ██║  ██║╚██████╔╝██╔╝ ██╗██║ ╚═╝ ██║╚██████╔╝██╔╝ ██╗
    ╚═╝  ╚═╝ ╚════╝ ╚══════╝     ╚═════╝ ╚═╝  ╚═══╝    ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═╝

    By @ferr3ira-gabriel | Built with Droid | Based on tutorial by Garrett Mills
EOF
}

msg_info() {
  local msg="$1"
  echo -ne " ${HOLD} ${YW}${msg}...${CL}"
}

msg_start() {
  local msg="$1"
  echo -e " ${HOLD} ${YW}${msg}...${CL}"
}

msg_ok() {
  local msg="$1"
  echo -e "${BFR} ${CM} ${GN}${msg}${CL}"
}

msg_ok_nl() {
  local msg="$1"
  echo -e " ${CM} ${GN}${msg}${CL}"
}

msg_error() {
  local msg="$1"
  echo -e "${BFR} ${CROSS} ${RD}${msg}${CL}"
}

msg_warn() {
  local msg="$1"
  echo -e "${BFR} ${YW}⚠${CL} ${YW}${msg}${CL}"
}

spinner() {
  local pid=$1
  local delay=0.1
  local spin_i=0
  while ps -p "$pid" &>/dev/null; do
    printf "\r [%c] " "${SPINNER:spin_i++%4:1}"
    sleep $delay
  done
  printf "\r"
}

check_root() {
  if [[ $EUID -ne 0 ]]; then
    msg_error "This script must be run as root"
    exit 1
  fi
}

check_proxmox() {
  if ! command -v pveversion &>/dev/null; then
    msg_error "This script must be run on a Proxmox VE host"
    exit 1
  fi
}

load_kernel_modules() {
  msg_info "Loading required kernel modules on host"
  
  # Required modules for K3s/K8s networking
  local modules=("br_netfilter" "overlay" "ip_tables" "ip6_tables" "nf_nat" "xt_conntrack")
  
  for mod in "${modules[@]}"; do
    if ! lsmod | grep -q "^${mod}"; then
      modprobe "$mod" 2>/dev/null || true
    fi
  done
  
  # Persist modules across reboots
  for mod in "${modules[@]}"; do
    if ! grep -q "^${mod}$" /etc/modules 2>/dev/null; then
      echo "$mod" >> /etc/modules
    fi
  done
  
  # Set required sysctl params on host
  cat > /etc/sysctl.d/99-k3s.conf << 'EOF'
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward = 1
EOF
  sysctl --system &>/dev/null || true
  
  msg_ok "Loaded required kernel modules on host"
}

get_next_ct_id() {
  local start_id=${1:-100}
  while pct status "$start_id" &>/dev/null; do
    ((start_id++))
  done
  echo "$start_id"
}

get_available_storage() {
  pvesm status -content rootdir 2>/dev/null | awk 'NR>1 {print $1}' | head -1
}

get_available_templates() {
  pveam available --section system 2>/dev/null | grep -E "(debian|ubuntu|rocky)" | awk '{print $2}'
}

download_template() {
  local storage="$1"
  local template="$2"
  
  # Check if template already exists (use || true to prevent exit on no match)
  if pveam list "$storage" 2>/dev/null | grep -q "$template" 2>/dev/null; then
    msg_ok "Template ${template} already available"
    return 0
  fi
  
  msg_start "Downloading template ${template}"
  if pveam download "$storage" "$template"; then
    msg_ok_nl "Downloaded template ${template}"
  else
    msg_error "Failed to download template ${template}"
    return 1
  fi
}

validate_ip() {
  local ip="$1"
  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
    return 0
  else
    return 1
  fi
}

configure_lxc_for_k3s() {
  local ctid="$1"
  local conf_file="/etc/pve/lxc/${ctid}.conf"
  
  if [[ ! -f "$conf_file" ]]; then
    msg_error "Container config not found: ${conf_file}"
    return 1
  fi
  
  msg_info "Configuring LXC ${ctid} for K3s"
  
  # Add required LXC options for K3s/Docker
  if ! grep -q "lxc.apparmor.profile" "$conf_file"; then
    cat >> "$conf_file" <<EOF

# K3s/Docker required settings
lxc.apparmor.profile: unconfined
lxc.cgroup.devices.allow: a
lxc.cap.drop:
lxc.mount.auto: proc:rw sys:rw
EOF
  fi
  
  msg_ok "Configured LXC ${ctid} for K3s"
}

push_kernel_config() {
  local ctid="$1"
  local kernel_config="/boot/config-$(uname -r)"
  
  if [[ -f "$kernel_config" ]]; then
    msg_info "Pushing kernel config to container ${ctid}"
    pct push "$ctid" "$kernel_config" "$kernel_config"
    msg_ok "Pushed kernel config to container ${ctid}"
  else
    msg_warn "Kernel config not found: ${kernel_config}"
  fi
}

setup_kmsg_in_container() {
  local ctid="$1"
  
  msg_info "Setting up /dev/kmsg in container ${ctid}"
  
  # Wait for systemd to be ready
  local retries=30
  while ! pct exec "$ctid" -- systemctl is-system-running &>/dev/null; do
    retries=$((retries - 1))
    if [[ $retries -le 0 ]]; then
      msg_warn "Systemd not fully ready, continuing anyway..."
      break
    fi
    sleep 1
  done
  
  # Create the kmsg script
  pct exec "$ctid" -- bash -c 'cat > /usr/local/bin/conf-kmsg.sh << "KMSGEOF"
#!/bin/sh -e
if [ ! -e /dev/kmsg ]; then
    ln -s /dev/console /dev/kmsg
fi
mount --make-rshared /
KMSGEOF'
  
  pct exec "$ctid" -- chmod +x /usr/local/bin/conf-kmsg.sh
  
  # Create systemd service that runs BEFORE k3s
  pct exec "$ctid" -- bash -c 'cat > /etc/systemd/system/conf-kmsg.service << "SVCEOF"
[Unit]
Description=Make sure /dev/kmsg exists
DefaultDependencies=no
Before=sysinit.target k3s.service k3s-agent.service
After=systemd-tmpfiles-setup-dev.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/bin/conf-kmsg.sh

[Install]
WantedBy=sysinit.target
SVCEOF'
  
  # Enable and start the service
  pct exec "$ctid" -- systemctl daemon-reload 2>/dev/null || sleep 2
  pct exec "$ctid" -- systemctl enable conf-kmsg 2>/dev/null || true
  
  # Run immediately to create /dev/kmsg now
  pct exec "$ctid" -- /usr/local/bin/conf-kmsg.sh 2>/dev/null || true
  
  # Verify kmsg exists
  if pct exec "$ctid" -- test -e /dev/kmsg; then
    msg_ok "Set up /dev/kmsg in container ${ctid}"
  else
    msg_warn "/dev/kmsg creation may have failed in container ${ctid}"
  fi
}

ensure_kmsg_exists() {
  local ctid="$1"
  
  if ! pct exec "$ctid" -- test -e /dev/kmsg 2>/dev/null; then
    msg_info "Creating /dev/kmsg in container ${ctid}"
    pct exec "$ctid" -- ln -sf /dev/console /dev/kmsg
    pct exec "$ctid" -- mount --make-rshared / 2>/dev/null || true
    msg_ok "Created /dev/kmsg in container ${ctid}"
  fi
}

wait_for_container() {
  local ctid="$1"
  local timeout="${2:-60}"
  local count=0
  
  while ! pct exec "$ctid" -- echo "ready" &>/dev/null; do
    if [[ $count -ge $timeout ]]; then
      msg_error "Timeout waiting for container ${ctid}"
      return 1
    fi
    sleep 1
    ((count++))
  done
}

create_lxc_container() {
  local ctid="$1"
  local hostname="$2"
  local template="$3"
  local storage="$4"
  local template_storage="$5"
  local cores="$6"
  local memory="$7"
  local disk="$8"
  local ip="$9"
  local gateway="${10}"
  local password="${11}"
  local bridge="${12:-vmbr0}"
  
  msg_start "Creating LXC container ${ctid} (${hostname})"
  
  pct create "$ctid" "${template_storage}:vztmpl/${template}" \
    --hostname "$hostname" \
    --cores "$cores" \
    --memory "$memory" \
    --rootfs "${storage}:${disk}" \
    --net0 "name=eth0,bridge=${bridge},ip=${ip},gw=${gateway}" \
    --password "$password" \
    --unprivileged 0 \
    --features nesting=1,keyctl=1 \
    --onboot 1 \
    --start 0
  
  msg_ok_nl "Created LXC container ${ctid} (${hostname})"
}

start_container() {
  local ctid="$1"
  
  msg_start "Starting container ${ctid}"
  pct start "$ctid"
  wait_for_container "$ctid"
  msg_ok_nl "Started container ${ctid}"
}

ensure_curl_installed() {
  local ctid="$1"
  
  if ! pct exec "$ctid" -- which curl &>/dev/null; then
    msg_start "Installing curl and certificates on container ${ctid}"
    pct exec "$ctid" -- bash -c "export DEBIAN_FRONTEND=noninteractive && apt-get update && apt-get install -y --no-install-recommends curl ca-certificates"
    msg_ok_nl "Installed curl and certificates on container ${ctid}"
  else
    # Ensure CA certificates are installed even if curl exists
    if ! pct exec "$ctid" -- dpkg -l ca-certificates &>/dev/null; then
      msg_start "Installing CA certificates on container ${ctid}"
      pct exec "$ctid" -- bash -c "export DEBIAN_FRONTEND=noninteractive && apt-get update && apt-get install -y --no-install-recommends ca-certificates"
      msg_ok_nl "Installed CA certificates on container ${ctid}"
    fi
  fi
}

install_k3s_control() {
  local ctid="$1"
  local node_name="$2"
  
  # Check if K3s control plane is already installed
  if pct exec "$ctid" -- test -f /var/lib/rancher/k3s/server/node-token 2>/dev/null; then
    msg_ok "K3s control plane already installed on ${node_name}"
    return 0
  fi
  
  ensure_curl_installed "$ctid"
  ensure_kmsg_exists "$ctid"
  
  msg_start "Installing K3s control plane on ${node_name}"
  pct exec "$ctid" -- bash -c "curl -sfL https://get.k3s.io | sh -s - --disable traefik --node-name ${node_name}"
  msg_ok_nl "Installed K3s control plane on ${node_name}"
}

get_k3s_token() {
  local ctid="$1"
  pct exec "$ctid" -- cat /var/lib/rancher/k3s/server/node-token
}

get_k3s_kubeconfig() {
  local ctid="$1"
  pct exec "$ctid" -- cat /etc/rancher/k3s/k3s.yaml
}

install_k3s_worker() {
  local ctid="$1"
  local node_name="$2"
  local control_ip="$3"
  local token="$4"
  
  # Check if K3s agent is already installed
  if pct exec "$ctid" -- test -f /usr/local/bin/k3s 2>/dev/null; then
    msg_ok "K3s agent already installed on ${node_name}"
    # Ensure service is running
    pct exec "$ctid" -- systemctl start k3s-agent 2>/dev/null || true
    return 0
  fi
  
  ensure_curl_installed "$ctid"
  ensure_kmsg_exists "$ctid"
  
  msg_start "Joining worker ${node_name} to cluster"
  pct exec "$ctid" -- bash -c "curl -sfL https://get.k3s.io | K3S_URL=https://${control_ip}:6443 K3S_TOKEN=${token} sh -s - --node-name ${node_name}"
  msg_ok_nl "Joined worker ${node_name} to cluster"
}

install_helm() {
  local ctid="$1"
  
  # Check if Helm is already installed
  if pct exec "$ctid" -- test -f /usr/local/bin/helm 2>/dev/null; then
    msg_ok "Helm already installed"
    return 0
  fi
  
  ensure_curl_installed "$ctid"
  
  msg_start "Installing Helm"
  pct exec "$ctid" -- bash -c "export PATH=\$PATH:/usr/local/bin && curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash"
  
  # Verify installation
  if pct exec "$ctid" -- /usr/local/bin/helm version &>/dev/null; then
    msg_ok_nl "Installed Helm"
  else
    msg_error "Helm installation failed"
    return 1
  fi
}

install_nginx_ingress() {
  local ctid="$1"
  
  # Check if NGINX ingress is already installed
  if pct exec "$ctid" -- bash -c "export KUBECONFIG=/etc/rancher/k3s/k3s.yaml && /usr/local/bin/helm list -A 2>/dev/null | grep -q nginx-ingress"; then
    msg_ok "NGINX Ingress Controller already installed"
    return 0
  fi
  
  msg_start "Installing NGINX Ingress Controller"
  pct exec "$ctid" -- bash -c "
    export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
    export PATH=\$PATH:/usr/local/bin
    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx 2>/dev/null || true
    helm repo update
    helm install nginx-ingress ingress-nginx/ingress-nginx \
      --set controller.publishService.enabled=true \
      --wait=false
  "
  msg_ok_nl "Installed NGINX Ingress Controller"
}

install_ohmyzsh() {
  local ctid="$1"
  local hostname="$2"
  
  # Check if base packages are already installed
  if pct exec "$ctid" -- bash -c "which curl git telnet zsh" &>/dev/null; then
    msg_ok "Base packages already installed on ${hostname}"
  else
    msg_start "Installing base packages on ${hostname}"
    pct exec "$ctid" -- bash -c "export DEBIAN_FRONTEND=noninteractive && apt-get update && apt-get install -y --no-install-recommends curl ca-certificates git telnet zsh"
    msg_ok_nl "Installed base packages on ${hostname}"
  fi
  
  # Check if Oh My Zsh is already installed
  if pct exec "$ctid" -- test -d /root/.oh-my-zsh 2>/dev/null; then
    msg_ok "Oh My Zsh already installed on ${hostname}"
  else
    msg_start "Installing Oh My Zsh on ${hostname}"
    pct exec "$ctid" -- bash -c '
      export RUNZSH=no
      export CHSH=no
      sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
    '
    msg_ok_nl "Installed Oh My Zsh on ${hostname}"
  fi
  
  # Ensure fino theme is set
  pct exec "$ctid" -- bash -c 'sed -i "s/ZSH_THEME=\"robbyrussell\"/ZSH_THEME=\"fino\"/" ~/.zshrc' 2>/dev/null || true
  
  # Ensure zsh is default shell (use usermod to avoid password prompt)
  pct exec "$ctid" -- usermod -s /bin/zsh root 2>/dev/null || true
  
  # Add exec zsh to .bashrc for Proxmox console compatibility
  if ! pct exec "$ctid" -- grep -q "exec zsh" /root/.bashrc 2>/dev/null; then
    pct exec "$ctid" -- bash -c 'echo "exec zsh" >> /root/.bashrc'
  fi
}

cleanup_on_error() {
  local ctids=("$@")
  msg_warn "Cleaning up containers due to error..."
  for ctid in "${ctids[@]}"; do
    if pct status "$ctid" &>/dev/null; then
      pct stop "$ctid" 2>/dev/null || true
      pct destroy "$ctid" 2>/dev/null || true
    fi
  done
}
